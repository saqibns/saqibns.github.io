<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Predicting Emotions of a Group</title>
  <meta name="description" content="Emotion Recognition In the Wild (EmotiW) is a competition organized under the umbrella of International Conference on Multimodal Interaction (ICMI). The competition is being organized since 2013. The competition for the year 2017 consisted of two sub-challenges :">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2017/12/30/predicting-emotions-of-a-group/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Saqib&#39;s Blog" href="http://localhost:4000/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="saqibns">
  <meta name="twitter:title" content="Predicting Emotions of a Group">
  <meta name="twitter:description" content="Emotion Recognition In the Wild (EmotiW) is a competition organized under the umbrella of International Conference on Multimodal Interaction (ICMI). The competition is being organized since 2013. T...">
  
    <meta name="twitter:creator" content="saqibns">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Saqib&#39;s Blog</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Predicting Emotions of a Group</h1>
    
    <p class="post-meta"><time datetime="2017-12-30T01:32:28+05:30" itemprop="datePublished">Dec 30, 2017</time>
</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://sites.google.com/site/emotiwchallenge/">Emotion Recognition In the Wild (EmotiW)</a> is a competition organized under the umbrella of <a href="https://icmi.acm.org/2017/">International Conference on Multimodal Interaction (ICMI)</a>. The competition is being organized since 2013. The  competition for the year 2017 consisted of two sub-challenges :</p>

<ul>
  <li>Group Level Emotion Recognition</li>
  <li>Audio-Video Emotion Recognition</li>
</ul>

<p>I participated in the former with Bhanu Pratap Singh Rawat and Manya Wadhwa. We were given a dataset which contained photographs of groups of people. The aim of the sub-challenge was to come up with a model that could classify the emotion the group as <code class="highlighter-rouge">Positive</code>, <code class="highlighter-rouge">Negative</code> or <code class="highlighter-rouge">Neural</code>. This post describes our approach for the challenge.</p>

<h2 id="dataset">Dataset</h2>

<p>The dataset was divided into three parts: train, validation and test. Each part consisted of image files for each of our target categories: <code class="highlighter-rouge">Positive</code>, <code class="highlighter-rouge">Negative</code> or <code class="highlighter-rouge">Neutral</code>. The distribution of images in the dataset is:</p>

<table class="mbtablestyle">
  <thead>
    <tr>
      <th>Set</th>
      <th>Positive</th>
      <th>Neutral</th>
      <th>Negative</th>
      <th>Total</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Train</strong></td>
      <td>1272</td>
      <td>1199</td>
      <td>1159</td>
      <td>3630</td>
    </tr>
    <tr>
      <td><strong>Validation</strong></td>
      <td>773</td>
      <td>728</td>
      <td>564</td>
      <td>2065</td>
    </tr>
    <tr>
      <td><strong>Test</strong></td>
      <td>311</td>
      <td>165</td>
      <td>296</td>
      <td>772</td>
    </tr>
  </tbody>
</table>

<p>A sample of images from the dataset is given below:</p>

<p><img src="/assets/emotiw-17/group_snapshot.png" alt="Sample Images in the EmotiW Dataset" /></p>

<h2 id="method">Method</h2>

<p><strong>Summary:</strong> We used ConvNets for our task with emotion heatmaps as features. If you wish to know the specifics of what emotion heatmaps are, read on!</p>

<h3 id="emotion-of-individual-faces">Emotion of Individual Faces</h3>

<p>The first step of our approach was to extract faces from each file and determine the emotion of each face. We extracted faces from the files using <a href="http://dlib.net/">Dlib</a> and determined the emotion for each of the extracted faces. This was done using the pre-trained <a href="https://www.openu.ac.il/home/hassner/projects/cnn_emotions/">models</a> by Gil Levi and Tal Hassner developed for EmotiW 2015 (we shall refer to them as <em>LHModels</em> throughout the post). It is a set of five models which assign scores for seven standard emotions: Anger, Disgust, Fear, Happy, Neutral, Sad and Surprise. A single score for each face across the seven categories is obtained by averaging the five scores obtained for each category.</p>

<h3 id="combination-of-values">Combination of Values</h3>

<p>Once we obtained face wise emotions, a logical next step was to use the scores obtained for individual faces and somehow combine them to enable a learning algorithm to accurately determine the emotion of a group.</p>

<p>We averaged five vectors obtained for every face in the image. The emotion with the highest value was said to be the overall emotion of the group. We then trained a Random Forest Classifier (15 estimators) with the averaged seven-dimensional vector for each image.</p>

<p>For both of the cases above, if an image was labeled as one of Anger, Disgust, Fear, Sadness or Surprised the final label assigned to it was Negative, Neutral was assigned Neutral and Happy was assigned Positive. The performance for each of the approaches is summarized in a table later.</p>

<p>We then used the predictions of LHModels to generate heatmaps for our images. The first step was to convert the seven-dimensional vectors into three-dimensional vectors representing our three categories of interest, <code class="highlighter-rouge">Positive</code>, <code class="highlighter-rouge">Negative</code> and <code class="highlighter-rouge">Neutral</code>. We did this by taking the average of Anger, Disgust, Fear, Sadness and Surprised designating it the label <code class="highlighter-rouge">Negative</code>, Happy was given the label <code class="highlighter-rouge">Positive</code>, and Neutral was assigned <code class="highlighter-rouge">Neutral</code>.</p>

<p>After this step, we had a set of three values for every face (one corresponding to each emotion). We used those to create three heatmaps, which, actually, are Gaussian interpolations of those values in a two-dimensional space.  The code snippet below creates a two-dimensional Gaussian kernel. The height and width of the kernel are same as that of the image in which the face was present. When interpolating, we observed that the values fell quickly as we went away from the center of the heatmap, since the distance increases rapidly. We used a value of 0.1 to make the values decrease gradually over distance (in other words, the effective distance from one pixel to the next was reduced to 1/10<sup>th</sup> of its original value).</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">DISTANCE_SMOOTHING</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="k">def</span> <span class="nf">make_gaussian</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
    <span class="s">""" Make a square gaussian kernel.
    fwhm is full-width-half-maximum, which
    can be thought of as an effective radius.
    """</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">size</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">center</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">DISTANCE_SMOOTHING</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">DISTANCE_SMOOTHING</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y0</span><span class="p">))</span> <span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">fwhm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</code></pre>
</div>

<p>The kernel is then multiplied by the value of the emotion for that face. Let us take the face below as an example:</p>

<p><img src="/assets/emotiw-17/image_0_0.jpg" alt="image_0_0" /></p>

<p>The heatmaps (2D Gaussian distributions) for <code class="highlighter-rouge">Negative</code>, <code class="highlighter-rouge">Positive</code> and <code class="highlighter-rouge">Neutral</code> emotion values for the above face are:</p>

<p><img src="/assets/emotiw-17/image_0_0.jpg_gaussian_neg-crop.png" alt="image_0_0.jpg_gaussian_neg-crop" /></p>

<p><img src="/assets/emotiw-17/image_0_0.jpg_gaussian_neu-crop.png" alt="image_0_0.jpg_gaussian_neu-crop" /></p>

<p><img src="/assets/emotiw-17/image_0_0.jpg_gaussian_pos-crop.png" alt="image_0_0.jpg_gaussian_pos-crop" /></p>

<p>We, then used the individual heatmaps as channels of an RGB image, with distribution for <code class="highlighter-rouge">Negative</code> emotion being the red channel and those of <code class="highlighter-rouge">Neutral</code> and <code class="highlighter-rouge">Positive</code> forming the green and the blue channels respectively. For the face shown above, the final heatmap looks like the image below:</p>

<p><img src="/assets/emotiw-17/image_0_0.jpg_combined.png" alt="image_0_0.jpg_combined" /></p>

<p>We carry out this process for every face in an image and finally add the RGB images tensor together, thus forming a single image.</p>

<p><img src="/assets/emotiw-17/image-process.jpg" alt="image process" /></p>

<p>​The image above demonstrates the entire process of converting an image to a heatmap. The final heatmap was then resized and fed to Convolutional Neural Networks. Using this methodology, we achieved a classification accuracy of 56.47% on the validation set. The baseline was 52.79%.</p>

<p>A table summarizing the performance of the approaches is given below.</p>

<table>
  <thead>
    <tr>
      <th>Model</th>
      <th>Training Accuracy</th>
      <th>Validation Accuracy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Baseline</td>
      <td>-</td>
      <td>52.79%</td>
    </tr>
    <tr>
      <td>Averaging</td>
      <td>44.37%</td>
      <td>42.38%</td>
    </tr>
    <tr>
      <td>Random Forest</td>
      <td>99.08%</td>
      <td>48.13%</td>
    </tr>
    <tr>
      <td>ConvNet on Heatmaps</td>
      <td>54.16%​</td>
      <td>56.47%</td>
    </tr>
  </tbody>
</table>

<p>Please refer to our <a href="https://arxiv.org/abs/1710.01216">paper</a> for more details.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
 
    var disqus_config = function () {
        this.page.url = saqibns.github.io;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = "/2017/12/30/predicting-emotions-of-a-group"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
 
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = 'https://saqibns-github-io.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Saqib Nizam Shamsi - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="http://localhost:4000/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
